# Chapter 3

## 리스트와 튜플
튜플은 **불변**(immutable)한다. 리스트는 **변경 가능**(mutable)하다.

### 리스트 생성하기: `[]` 또는 `list()`

```python
empty_list = []
weekdays = ['Monday', 'Tuesday', 'Wednsday', 'Thursday', 'Friday']
another_empty_list = list()
```

### 다른 데이터 타입을 리스트로 변환하기: `list()`
`list()` 함수는 다른 데이터 타입을 리스트로 변환한다.

```python
list('cat')
['c', 'a', 't']
```

### `[offset]`으로 항목 얻기
문자열과 마찬가지로 음수의 인덱스는 끝에서 거꾸로 값을 추출한다.

### 리스트의 리스트
리스트는 다음과 같이 리스트뿐만 아니라 다른 타입의 요소도 포함할 수 있다.

```python
small_birds = ['humingbird', 'finch']
extinct_birds = ['dodo', 'passenger pigeon', 'Norwegian Blue']
carol_birds = [3, 'French hens', 2, 'turtledoves']
all_birds = [small_birds, extinct_birds, 'maCaw', carol_birds]
```

### 슬라이스로 항목 추출하기
문자열과 동일하게 슬라이스를 사용해서 리스트의 서브시퀀스를 추출할 수 있다.

### 리스트의 끝에 항목 추가하기: `append()`
`append()`는 리스트의 끝에 새 항목을 추가한다. 리스트는 변경가능하기 때문에 추가가 가능하다.

### 리스트 병합하기: `extend()` 또는 `+=`
`extend()`를 사용하여 다른 리스트를 병합할 수 있다. `append()` 안에 다른 리스트를 넣으면 병합하지 않고, 하나의 리스트로 추가된다.

```python
marxes = ['Groucho', 'Chico', 'Harpo', 'Zeppo']
others = ['Gummo', 'Karl']
marxes.append(others)
['Groucho', 'Chico', 'Harpo', 'Zeppo', ['Gummo', 'Karl']]
```

### 오프셋과 `insert()`로 항목 추가하기
`append()` 함수는 단지 리스트의 끝에 항목을 추가한다. 그러나 `insert()` 함수는 원하는 위치에 항목을 추가할 수 있다. 리스트의 끝을 넘는 오프셋은 `append()` 처럼 끝에 항목을 추가한다.

### 오프셋을 항목 삭제하기: `del`
```python
marxes
['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo']
del marxes[-1]
['Groucho', 'Chico', 'Harpo', 'Gummo', 'Zeppo']
```
오프셋으로 리스트의 특정 항목을 삭제하면, 제거된 항목 이후의 항목들이 한 칸씩 앞으로 당겨진다. `del`은 리스트의 함수가 아니라 파이썬 구문이다. 즉 `marxes[-2].del()`을 수행할 수 없다. `del`은 할당(`=`)의 반대다. 이것은 객체로부터 이름을 분리하고, (이 이름이 객체의 마지막 참조일 경우) 객체의 메모리를 비워준다.

### 값으로 항목 삭제하기: `remove()`
리스트에서 삭제할 항목의 위치를 모르는 경우, `remove()`와 값으로 그 항목을 삭제할 수 있다. 항목이 여러개 있을 경우 맨 앞의 항목이 삭제된다.

### 오프셋으로 항목을 얻은 후 삭제하기: `pop()`
`pop()`은 리스트에서 항목을 가져오는 동시에 그 항목을 삭제한다. 오프셋과 함께 `pop()`을 호출했다면 그 오프셋의 항목이 반환된다. 인자가 없다면 `-1`을 사용한다.


### 값으로 항목 오프셋 찾기: `index()`
항목 값의 리스트 오프셋을 알고 싶다면 `index()`를 사용하면 된다. 여러개의 항목이 있을 경우 가장 앞의 오프셋이 반환 된다.

### 존재여부 확인하기: `in`
리스트에서 어떤 값의 존재를 확인하려면 `in`을 사용한다.

```python 
marxes = ['Grouch', 'Chico', 'Harpo', 'Zeppo']
'Groucho' in marxes
True
'Bob' in marxes
False
```

### 값 세기: `count()`
리스트에 특정 값이 얼마나 있는지 세기 위해서는 `count()`를 사용한다.

### 문자열로 변환하기: `join()`
```python
marxes = ['Grouch', 'Chico', 'Harpo']
', '.join(marxes)
'Grouch, Chico, Harpo'
```
`join()`은 문자열 메서드지, 리스트 메서드가 아니다. `marxes.join(', ')` 과 같이 사용할 수 없다.

### 정렬하기: `sort()`
오프셋을 이용하여 리스트를 정렬할 때도 있지만, 값을 이용하여 리스트를 정렬할 때도 있다. 파이썬은 두 가지 함수를 제공한다.

* `sort()`는 리스트 자체를 내부적으로 정렬한다.
*  `sorted()`는 리스트의 정렬된 복사본을 반환한다.

리스트의 항목이 숫자인 경우, 기본적으로 오름차순으로 정렬한다. 문자열인 경우, 알파벳순으로 정렬한다. 리스트의 요소들이 모두 같은 타입일 경우 `sort()`는 제대로 동작한다. 때때로 정수와 부동소수점수 같이 혼합된 타입도 정렬할 수 있다. 파이썬이 자동으로 타입을 형변환해서 항목들을 정렬하기 때문이다. 내림차순으로 정렬하고 싶다면 인자에 `reverse=True`를 추가한다.

### 할당: `=`, 복사: `copy()`
한 리스트를 변수 두 곳에 할당했을 경우, 한 리스트를 변경하면 다른 리스트도 따라서 변경된다. 변수들은 단지 같은 리스트 객체를 참조 하고 있을 뿐이다. 다음과 같은 방법을 이용하여 한 리스트를 새로운 리스트로 복사할 수 있다.

* `copy()` 함수
* `list()` 변환 함수
* 슬라이스 `[:]`

```python
a = [1, 2, 3]
b = a.copy()
c = list(a)
d = a[:]
```

## 튜플
리스트와 마찬가지로 튜플은 임의적인 항목의 시퀀스다. 리스트와는 다르게 튜플은 **불변**한다. 이 말은 튜플을 정의한 후에는 추가, 삭제, 수정을 할 수 없다는 것을 의미한다.

### 튜플 생성하기: `()`
튜플의 구문운 리스트와 조금 다르다. `()`로 튜플을 만든다. 두 개 이상의 요소가 있을 경우, 마지막 요소에는 콤마를 붙이지 않는다. 파이썬은 튜플을 출력할 때 괄호 `()`를 포함한다. 튜플을 정의할 때는 괄호 `()`가 필요 없다. 두에 콤마가 붙는다는 것은 튜플을 정의한다는 뜻이다. 튜플은 한 번에 여러 변수를 할당할 수 있다.

```python
marx_tuple = ('Groucho', 'Chico', 'Harpo')
a, b, c = marx_tuple
```
`tuple()`은 다른 객체를 튜플로 만들어준다.

```python
marx_list = ['Groucho', 'Chico', 'Harpo']
tuple(marx_list)
('Groucho', 'Chico', 'Harpo')
```

### 튜플과 리스트 
리스트를 대신해서 튜플을 사용할 수 있다. 하지만 튜플은 리스트의 `append()`, `insert()` 등과 같은 함수가 없고, 함수의 수가 매우 적다. 튜플을 생성한 후에는 수정할 수 없기 때문이다. 튜플을 사용하는 이유는 다음과 같다.

* 튜플은 더 적은 공간을 사용한다.
* 실수로 튜플의 항목이 손상될 염려가 없다.
* 튜플을 딕셔너리 키로 사용할 수 있다.
* **네임드 튜플**은 객체의 단순한 대안이 될 수 있다.
* 함수의 인자들은 튜플로 전달된다.

## 딕셔너리
**딕셔너리**는 리스트와 비슷하다. 다른 점은 항목의 순서를 따지지 않으며, 0 또는 1과 같은 오프셋으로 항목을 선택할 수 없다. 대신 값에 해당하는 고유한 **키**를 지정한다. 이 키는 대부분 문자열이지만, 불면하는 파이썬의 어떤 타입(부울, 정수, 부동소수점수, 튜플, 문자열등)이 될 수도 있다. 딕셔너리는 변경 가능하므로 키-값 요소를 추가, 삭제, 수정할 수 있다.

### 딕셔너리 생성하기: `{}`
딕셔너리를 생성하기 위해서는 중괄호(`{}`) 안에 콤마로 구분된 **키:값** 쌍을 지정한다.

```python
dict = { 
	1: 'hi',
	2: 'hello'
	}
```

### 딕셔너리로 변환하기: `dict()`
`dict()` 함수를 사용해서 두 값으로 이루어진 시퀀스를 딕셔너리로 변환할 수 있다. 

```python
lol = [['a', 'b'], ['c', 'd'], ['e', 'f']]
dict(lol)
{'c': 'd', 'a': 'b', 'e': 'f'}
```

### 항목 추가/변경하기: `[key]`
딕셔너리에 항목을 추가하는 것은 간단하다. 키에 의해 참조되는 항목에 값을 할당하면 된다. 키가 딕셔너리에 이미 존재하는 경우, 그 값은 새 값으로 대체된다. 키가 존재하지 않는 경우, 새 값이 키와 사전에 추가된다. 리스트와 달리 딕셔너리를 할당할 때는 인덱스의 범위 지정이 벗어 났다는 예외에 대해 걱정할 필요가 없다. 리스트의 키는 유일해야 한다. 만약 같은 키를 두 번 이상 사용하면 마지막 값이 승리한다.

### 딕셔너리 결합하기: `update()`
`update()` 함수는 한 딕셔너리의 키와 값들을 복사해서 다른 딕셔너리에 붙여준다. 리스트의 `extend()`와 비슷하다. 두 번째 딕셔너리를 첫 번째 딕셔너리에 병합하려고 하는데, 두 딕셔너리에 같은 키값이 있다면 무슨 일이 벌어질까? 두 번째 딕셔너리에 있는 값이 승리한다.

### 키와 `del`로 삭제하기
리스트에서의 사용법과 동일하다.

```python
del pythons['Marx']
```

### 모든항목 삭제하기: `clear()`
딕셔너리에 있는 키와 값을 모두 삭제하기 위해서는 `clear()`을 사용하거나 빈 딕셔너리(`{}`)를 이름에 할당한다.

### `in`으로 키 멤버십 테스트하기
딕셔너리에 키가 존재하는지 알고 싶다면 `in`을 사용한다. 

```python
'Gilliam' in pythons
False
```

### 항목얻기: `[key]`
딕셔너리에 키가 존재하지 않으면 예외를 얻게 된다. 이 문제를 피하기 위해서 `in`으로 키에 대한 멤버십 테스트를 실행하는 방법이 있다. 두 번째 방법은 딕셔너리의 `get()` 함수를 사용하는 것이다. 이 함수는 딕셔너리, 키, 옵션값을 사용한다. 만약 키가 존재하면, 그 값을 얻는다. 만약 키가 존재 하지 않으면, 옵션값을 지정해서 이를 출력할 수 있다.

```python
pythons.get('Marx', 'Not a python')
'Not a python'
```
옵션값을 지정하지 않으면 `None`을 얻는다.

### 모든 키 얻기: `keys()`
딕셔너리의 모든 키를 가져오기 위해서는 `keys()`를 사용한다.

### 모든 값 얻기: `values()`
딕셔너리의 모든 값을 가져오기 위해서는 `values()`를 사용한다.

### 모든 쌍의 키-값 얻기: `items()`
딕셔너리의 모든 쌍의 키와 값을 얻기 위해서는 `items()`를 사용한다. 각 키와 값은 튜플로 반환된다.

### 할당: `=`, 복사: `copy()`
리스트와 마찬가지로 딕셔너리를 할당한 후 변경할 때 딕셔너리를 참조하는 모든 이름에 변경된 딕셔너리를 반영한다. 그러므로 딕셔너리의 키와 값을 또 다른 딕셔너리로 복사하기 위해서는 할당하지 않고 `copy()`를 사용한다.

## 셋
**셋**은 값은 버리고 키만 남은 딕셔너리와 같다. 딕셔너리와 마찬가지로 각 키는 유일해야 한다. 어떤 것이 존재하는지 여부만 판단하기 위해서는 셋을 사용한다. 그리고 키에 어떤 정보를 첨부해서 그 결과를 얻고 싶으면 딕셔너리를 사용한다. 

### 셋 생성하기: `set()`
셋을 생성할 때는 `set()` 함수 혹은(`{}`) 안에 콤마로 구분된 하나 이상의 값을 넣으면 된다. 딕셔너리와 마찬가지로 셋은 순서가 없다.

> `{}`는 빈 딕셔너리를 생성한다. 이것이 인터프리터가 빈 셋을 `{}`대신 `set()`으로 출력하는 이유이기도 하다.

### 데이터 타입 변환하기: `set()`
리스트, 문자열, 튜플, 딕셔너리로부터 중복된 값을 버린 셋을 생성할 수 있다. 딕셔너리에 `set()`을 사용하면 키만 사용한다.

### 콤비네이션과 연산자
셋 인터섹션 연산자는 앰퍼샌드(`&`)이다

```python
for name, contents in drinks.items():
	if contents & {'vermouth', 'orange juice'}:
		print(name)
```
`&` 연산자의 결과는 우리가 비교하고자 했던 두 재료의 모든 항목이 포함된 셋이다. `contents`에 두 재료가 없다면, `&`은 `False`로 간주되는 빈 셋을 반환한다. `|`: 유니온, `-` 디퍼런스, `^`: 익스클루시브.